import os
from typing import List, Optional
import qdrant_client
from qdrant_client.http import models
import google.generativeai as genai
from dotenv import load_dotenv
from sqlalchemy import create_engine, Column, Integer, String, Text, DateTime, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship
from datetime import datetime
import uuid

load_dotenv()

# Initialize Qdrant client
qdrant_client_instance = qdrant_client.QdrantClient(
    url=os.getenv("QDRANT_URL"),
    api_key=os.getenv("QDRANT_API_KEY"),
)

# Configure Google Gemini
genai.configure(api_key=os.getenv("GEMINI_API_KEY"), transport="rest")

# Database configuration for Neon PostgreSQL
DATABASE_URL = os.getenv("DATABASE_URL")

# Create SQLAlchemy engine for Neon PostgreSQL
engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,  # Verify connections before use
    pool_recycle=300,    # Recycle connections every 5 minutes
    echo=False           # Set to True for SQL query logging
)

# Create session factory
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# Base class for SQLAlchemy models
Base = declarative_base()

def get_db():
    """Dependency to get database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def get_embedding(text: str, task_type: str = "retrieval_document") -> List[float]:
    """Generate embedding for text using Google Gemini"""
    try:
        embedding = genai.embed_content(
            model="models/text-embedding-004",
            content=text,
            task_type=task_type
        )
        return embedding['embedding']
    except Exception as e:
        raise Exception(f"Error generating embedding: {str(e)}")

def initialize_collection(collection_name: str) -> None:
    """Initialize Qdrant collection with cosine distance"""
    try:
        collections = qdrant_client_instance.get_collections()
        collection_names = [c.name for c in collections.collections]

        if collection_name not in collection_names:
            qdrant_client_instance.create_collection(
                collection_name=collection_name,
                vectors_config=models.VectorParams(
                    size=768,  # 768-dim for Gemini embeddings
                    distance=models.Distance.COSINE
                )
            )
            print(f"Collection '{collection_name}' created successfully")
        else:
            print(f"Collection '{collection_name}' already exists")
    except Exception as e:
        raise Exception(f"Error initializing collection: {str(e)}")

# SQLAlchemy Models for Better Auth + Chat History
# Using camelCase column names as per Better Auth convention
class User(Base):
    __tablename__ = "user"

    id = Column("id", String, primary_key=True)  # UUID string generated by Better Auth
    email = Column("email", String, unique=True, nullable=False)  # User's email address
    name = Column("name", String, nullable=False)  # User's full name
    education_level = Column("educationLevel", String)  # Education level enum
    programming_experience = Column("programmingExperience", String)  # Programming experience enum
    software_background = Column("softwareBackground", Text)  # Software background description
    hardware_background = Column("hardwareBackground", Text)  # Hardware background description
    robotics_background = Column("roboticsBackground", String)  # Robotics background enum
    created_at = Column("createdAt", DateTime, default=datetime.utcnow)  # Account creation timestamp

class Session(Base):
    __tablename__ = "session"

    id = Column("id", String, primary_key=True)  # UUID string generated by Better Auth
    user_id = Column("userId", String, ForeignKey("user.id", ondelete="CASCADE"), nullable=False)  # References User.id
    token = Column("token", String)  # Session authentication token
    expires_at = Column("expiresAt", DateTime, nullable=False)  # Session expiration timestamp

    # Relationship
    user = relationship("User", back_populates="sessions")

User.sessions = relationship("Session", order_by=Session.expires_at, back_populates="user")

class ChatHistory(Base):
    __tablename__ = "chat_history"

    id = Column("id", Integer, primary_key=True, autoincrement=True)  # Auto-incrementing integer
    user_id = Column("userId", String, ForeignKey("user.id", ondelete="CASCADE"), nullable=False)  # References User.id
    message = Column("message", Text, nullable=False)  # User's question/message to the chatbot
    response = Column("response", Text, nullable=False)  # AI assistant's response
    selected_text = Column("selectedText", Text)  # Text selected from documentation (optional context)
    created_at = Column("createdAt", DateTime, nullable=False, default=datetime.utcnow)  # Message timestamp

    # Relationship
    user = relationship("User", back_populates="chat_histories")

User.chat_histories = relationship("ChatHistory", order_by=ChatHistory.created_at.desc(), back_populates="user")

def create_tables():
    """Create all database tables"""
    Base.metadata.create_all(bind=engine)